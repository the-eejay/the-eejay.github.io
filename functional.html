<!DOCTYPE html>
<html>
	<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Functional Testing</title>
	<link rel="stylesheet" type="text/css" href="Website/style/style.css">
	<script src="Website/scripts/drop-down-menu.js"></script>
	</head>

	<body>
		<div id="body-wrapper">
			<div id="header">
				<img src="Website/images/logo.png" alt="spacecog logo" height="80px;"/>
				<div id="nav-bar">
					<ul>
						<li><a href="http://the-eejay.github.io/">Home</a></li>
						<li><a href="essay.html">Evaluation</a></li>
						<li><a class="current-page" href="#"
							onmouseover="mopen('m1')" 
							onmouseout="mclosetime()">Testing</a>
							<div id="m1" 
								onmouseover="mcancelclosetime()" 
								onmouseout="mclosetime()">
							<a href="#">User Testing</a>
							<a href="functional.html">Functional Testing</a>
							</div>
						</li>
						<li><a href="guides.html">Guides</a></li>
						<li><a href="faq.html">FAQ</a></li>
						<li><a href="media.html">Media</a></li>
						<li><a href="download.html">Downloads</a></li>
					</ul>
				</div>
			</div>
			<div class="content">
				<center><h2>Functional Testing</h2></center>
				<h3 class="title">EnemyScript</h3>
				<p>The EnemyScript is never directly used. It shares common information on the two types of enemies, and is therefore inherited from in BomberScript and SparrowScript. It implements only two methods, one to be run when instantiated, and another when destroyed.</p>
				<p><strong>Test 1:</strong> does it correctly find the WorldScriptObject on instantiation?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> Due to the simplicity of this function, and the fact that it is based on the initialization of a static object, both black-box and white-box testing are achieved by instantiating two objects using this script.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 2:</strong> does it correctly play an explosion noise on destruction?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> There are no branching statements in this function. Comprehensive testing is achieved by destroying an object using this script.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				
				<h3 class="title">BomberScript</h3>
				<p>The BomberScript is an extension of the EnemyScript, to be used on the ‘bomber’ class enemies (the little yellow kamikazes). It implements only one additional method, to be run when it collides with a player.</p>
				<p><strong>Test 3:</strong> does it correctly deal damage to a player and destroy itself on impact?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> OnCollisionEnter requires a Collision argument, which cannot be custom generated by a script. We rely on the engine to test this; therefore we must spawn a player and a bomber and collide them.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 4:</strong> does it correctly NOT do anything if a collision is not with a player?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> OnCollisionEnter requires a Collision argument, which cannot be custom generated by a script. We rely on the engine to test this, therefore we must spawn a bomber and another non-player and collide them.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				
				<h3 class="title">SparrowScript</h3>
				<p>The SparrowScript implements no additional functionality. It is a placeholder for future expansion. With no additional functionality, there is nothing to test.</p>
				
				<h3 class="title">BulletScript</h3>
				<p>The BulletScript dictates the behavior of bullet objects. Its responsibilities include destroying the bullets after a certain time (to save memory), and to deal damage to anything it impacts. </p>
				<p><strong>Test 5:</strong> does it initialize correctly?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> Bullet initialization involves determining the current time, ensuring that the WorldScriptObject has been found, and setting the physics engine to ignore collisions with other bullets. Both black-box and white-box testing are achieved by instantiating two objects using this script.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 6:</strong> does it NetworkInstantiate correctly?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> when spawned over the network, the bullet should initially have its renderer disabled. This is a trick to improve the fluidity of network lag issues. </li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 7:</strong> does it correctly damage things it impacts?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> OnCollisionEnter requires a Collision argument, which cannot be custom generated by a script. We rely on the engine to test this; therefore we must spawn a player and a bullet and collide them. We also spawn an enemy and a bullet and collide them, to ensure that both are working as intended.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 8:</strong> does it correctly manage the stages of its life?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> A short time after spawning, it is meant to enable its renderer so that it may be seen. A long time after spawning, it is meant to destroy itself, to help conserver memory. We test this by spawning a bullet and noting the times when each even occurs (if at all).</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				
				<h3 class="title">PlayerShipScript</h3>
				<p>The PlayerShipScript is attached to all player ships, and serves as an interface to a list of properties that other scripts may need to access. It implements no additional functionality, and therefore requires no testing.</p>
				
				<h3 class="title">UpgradeScript</h3>
				<p>The UpgradeScript is related to the game’s ship upgrade system. It simply implements the functionality for the upgrade button. </p>
				<p><strong>Test 9:</strong> does it correctly upgrade the player’s weapons if money is at least 20?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> by calling this function after setting the player’s money to 20, it is a simple matter to test this functionality. We also try with several higher values than 20, to ensure that it continues to work.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 10:</strong> does it correctly do nothing if the player’s money < 20?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> by calling this function after setting the player’s money to 19, it is a simple matter to test this functionality. We also try with several higher values lower than 19, to ensure that it continues to work.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				
				<h3 class="title">SpawnAsteroid</h3>
				<p>The SpawnAsteroidsScript handles littering the environment with randomly generated debris. It implements a single function.</p>
				<p><strong>Test 11:</strong> does this correctly spawn asteroids randomly?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> this was tested qualitatively, due to the inherent unpredictability of random generation. Simply call this function and observe the results in the game engine.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				
				<h3 class="title">ExitButtonScript</h3>
				<p>The ExitButtonScript is a simple script used by the gameover screen within the game. It allows the gameover button to disconnect the player from the server, and then reloads the main menu scene.</p>
				<p><strong>Test 12:</strong> does this correctly load the main menu, and disconnect from the host?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> all that was needed to test this method was to call it in game and read debug logs.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				
				<h3 class="title">MainMenuScript</h3>
				<p>The MainMenuScript is our first large script. It handles almost everything that happens within the main menu screen. Due to the networked nature of this game and this script, it is inconceivable that all possibilities are comprehensively tested for. We only cover the most significant ones here.</p>
				<p><strong>Test 13:</strong> do all initializations complete successfully?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> Watch for exceptions when initializing the main menu.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 14:</strong> can the ship choice be changed with ‘A’ and ‘D’?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> Pressing the ‘A’ and ‘D’ keys on the keyboard should cycle through a list of ships the player may choose from. To pass this test, they should obviously visually cycle, the stats and information panel should update to the relevant ship, and a player’s choice should carry over into games.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 15:</strong> can the player launch a single-player game?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> Pressing the Single Player button should allow a user to play a single-player game. This test does not test if the game itself works, but only that Unity loads up the game scene without any clients connected.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 16:</strong> can the player host a server?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> There are a number of steps involved in this test. This involves testing that the player can open a listen port when they press Host. It also involves getting a game name from the user for their game. It also involves reading the Master Server’s logs to ensure that game was successfully registered. It also involves ensuring that the host can successfully accept connections from other clients. This is not possible with unit testing.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 17:</strong> can a player leave their server?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> This is slightly more important and serious than just closing a UI element. If a host leaves the game then it is critical that all connected clients are disconnected and the game is unregistered from the Master Server as well.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 18:</strong> can the player browse a list of available servers?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> This test requires the game to query the Master Server for a list of running games, and then to use this information to present a list of games to the user in the form of clickable buttons.</li><br/>
					<li><strong>Results:</strong><span class="fail"> FAIL</span></li>
					<ul class="method-result">
						<li>This appears to work, but stops working at some point after the game has been running for too long or has already played games or connected to servers. The cause is currently unknown.</li>
					</ul>
				</ul>
				<p><strong>Test 19:</strong> can the player join one of the available servers?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> This test requires the game to query the Master Server for a list of running games, and then to use this information to present a list of games to the user in the form of clickable buttons. The player should then be able to click one of these buttons and automatically join the appropriate game.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 20:</strong> can players launch a multi-player game?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> Filling up a game lobby or pressing the Go Anyway button should allow all connected users to begin playing a multi-player game. This test does not test if the game itself works, but only that Unity loads up the game scene with any clients connected.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 21:</strong> can a player quit the game?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> Does pressing the Quit button close the game?</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				
				<h3 class="title">ClientScript</h3>
				<p>The ClientScript is basically just a script for holding properties to be shared around the network. Each player has their own ClientScript, which they will write to with their various control states. The server then reads from this script and uses the control state information to update the players. As a network component, this is hard to test, and will be mostly qualitative.</p>
				<p><strong>Test 22:</strong> can a client write to the variables in his own copy of this script?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> Ask the owner to write to his script and check that it believes it has done so. Then, try to read the same values from the script on another machine.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 23:</strong> will non-owners of the script NOT write to this script?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> Ask a non-owner to write to this script and check that it believes it has done so. Then, try to read the same values from the script on another machine. If it works, then this test fails.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				
				<h3 class="title">LocalGameScript</h3>
				<p>The LocalGameScript is a large script that handles everything in the gameplay from a client’s perspective. The number of functions here are too numerous to test, especially with networking involved, and so we will just pick out the most important ones.</p>
				<p><strong>Test 24:</strong> does this script simulate a server if running in single-player?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> All of the game logic in this code is divided up and interacts in a way that presupposes that there is a server and at least one client. If single-player works at all, then this must be succeeding.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 25:</strong> does this script launch a ServerGameScript if it is acting as the host?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> In single-player, a game must be acting as the host, and therefore should launch this script. In multi-player, only one of the games should launch this, and it should be the one that hosted the game.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 26:</strong> does this script initialize correctly with the server?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> Initialization across multiple games, in a specific order, is a nightmare to unit test comprehensively. The best we can do is to qualitatively observe the effects, and whether we believe that things are working as intended.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 27:</strong> does the camera remain centered on the player’s ship at all times?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> Play the game and move the ship. This test passes if the ship always appears to remain in the center of the screen.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 28:</strong> does the player’s radar work?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> The player’s radar is a circle of ‘blips’ that appear around their ship to indicate the presence of other ships. Blips should be the colour of their associated ship, and should reside on the perimeter of the circle such that the associated ship lies in the direction of that blip from the player’s ship.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 29:</strong> does the player’s health-bar work?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> A player’s health is mostly handled within the server script, but the visual feedback of it is handled here. For the health bar to be considered working, it must accurately reflect the player’s health at all times.</li><br/>
					<li><strong>Results:</strong><span class="fail"> FAIL</span></li>
					<ul class="method-result">
						<li>The health bar has a bug whereby a user can interact with it to artificially change its value in a way that does not reflect the player’s true health. To observe this, simply click and drag the health to a different point along the bar.</li>
					</ul>
				</ul>
				<p><strong>Test 30:</strong> does the game handle premature disconnects gracefully?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> Whenever someone disconnects from the game, something should be done about it. Things should be handled differently depending upon whether it was just a client that disconnect, or whether the host left.</li><br/>
					<li><strong>Results:</strong><span class="fail"> FAIL</span></li>
					<ul class="method-result">
						<li>If the host disconnects, all other players are told that they have won, without understanding why. If a player disconnects, nothing is done about it at all. Their ship keeps on floating until destroyed.</li>
					</ul>
				</ul>
				<p><strong>Test 31:</strong> does the game-over screen work as intended?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> When all players finally defeat the last remaining enemy on wave 20, or when all players have been destroyed, a Game Over screen should show up. Depending on the outcome, it should tell them that they either won or lost.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				
				<h3 class="title">ServerGameScript</h3>
				<p>The ServerGameScript is the last script, and it’s another big one. Obviously it deals with a substantial amount of networking, which makes it difficult to test with standard unit testing frameworks. Many of the following tests are qualitative, and the list is certainly not comprehensive.</p>
				<p><strong>Test 32:</strong> does the server create a ship for each player, of that player’s choice?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> Launch a game with multiple players, with differing ship choices for each player. Observe that everything worked as intended.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 33:</strong> does the server track damage for each ship, and destroy appropriately?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> Whenever a bullet impacts a ship, or a Bomber collides with a player, a ship is meant to take damage. Once the damage is greater than a ship’s HP, that ship should be destroyed.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 34:</strong> does the server spawn enemies in incrementally harder waves?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> The server is meant to spawn 20 waves of enemies, with each wave having greater numbers than the last. Waves don’t need to wait for the previous wave to be cleared though, in order to encourage aggressive play.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 35:</strong> does the server control all player ships as directed by clients?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> Although players direct their ships with their controls, it is the server that is responsible for actually moving them. This test simply ensures that it follows their directions.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
				<p><strong>Test 36:</strong> does the server AI control all enemy ships?</p>
				<ul class="method-result">
					<li><strong>Method:</strong> Nowhere else in any scripts have enemy movement, targeting, or shooting AI or protocols been defined. If they do anything at all, then this aspect of the server is working as intended.</li><br/>
					<li><strong>Results:</strong><span class="pass"> PASS</span></li>
				</ul>
			</div>
		</div>
	</body>

</html>